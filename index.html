
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Portfolio</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="styles.css"> 
</head>

<body>
  <header>
    <h1>Project Portfolio</h1>
    <p>A showcase for my best projects and what I'm currently working on</p>
    <hr></hr>

  </header>

  <main>

    <!-- Koca58 Section -->
    <div>
      <h2 id="Koca58"><a href="https://github.com/Hardware7253/Koca58">Koca58</a> - 2025</h2>
      <p>A split mechanical keyboard design</p>
      <div class="spacer"></div>

      <p>
        The Koca58 is a split mechanical keyboard design based on the Lily58; heavy modifications were made from the original to help this version reach a lower price point and have a more durable design.

        The Lily58 and many other split keyboards designed for hobbyists require microcontroller development boards to be soldered to unpopulated PCBs. This approach requires the user to be comfortable soldering and is more expensive.
        Instead, the Koca58 uses inexpensive surface mount components that don't need to be populated by hand.
        Lily58 surface mount boards do exist, but those use RP2040 microcontrollers. I switched to an STM32F103 chip for my board because they don't need external flash like the RP2040 (cheaper).
        Early prototypes of the Koca58 used a 3.5mm TRRS connector, but I switched to RJ45 to prevent hotplugging issues that many split keyboards with TRRS connectors are plagued with.
      </p>
      <p>
        The design uses a direct matrix for its keyswitches, meaning each switch gets its own pin on the microcontroller. Initially, this was chosen to avoid the use of key matrix diodes on the bottom of the PCB so double-sided PCBA wouldn't be necessary.
        Later on, I realised that getting the rear hot-swap sockets soldered by the PCBA company would be more economical than manual assembly. So I've kept the direct matrix part of the design so the same firmware can be used for all board revisions.
        This way I can sell some of the prototype boards without having to maintain a separate firmware version. The direct matrix led to some unideal PCB routing, but it was worth it to not turn half my prototypes into bricks.
      </p>
      <p>
        The case was designed in OnShape and features flexible mounting points to give a softer typing feel. There is also a flexible cutout so the MCU reset button can easily be pressed with the case installed.
      </p>
      <p>
        Like many other mechanical keyboards, the Koca58 runs the QMK firmware. The firmware files have been merged into the <a href="https://github.com/qmk/qmk_firmware/tree/master/keyboards/koca58">QMK GitHub repo.</a>
      </p>

      <div class="gallery">
        <img src="Pics/Koca58/Prototype.jpg">
        <img src="Pics/Koca58/CaseTop.png">
        <img src="Pics/Koca58/CaseBottom.png">
      </div>
      <hr></hr>
    </div>

    <!-- Nixie Tube Clock Section -->
    <div>
      <h2 id="Nixie Tube Clock"><a href="https://github.com/Hardware7253/OperationUrd">Nixie Tube Clock</a> - 2024</h2>
      <p>A nixie tube clock inspired by the divergence meter from Steins;Gate</p>
      <div class="spacer"></div>

      <p>
        This clock was a one-off gift I made for a friend. It has an RTC to accurately keep track of time, and its time is adjustable using the 3 mechanical switches. 
        One of the toggle switches turns the clock on/off; the other switch toggles an alternate mode. The alternate mode displays one of the worldline numbers from Steins;Gate.
        The clock also features an anti-poison routing that runs roughly every 10 minutes to prevent nixie tube cathode poisoning. This feature works by cycling all the digits on each nixie tube for about 15 seconds.
      </p>
      <p>
        The clock uses an STM32F103Cx microcontroller for its low cost and wide availability. I generally prefer STM32 microcontrollers because they are widely supported by the Rust community. Naturally, I used Rust to program the software for this project.
        To power the nixie tubes, I designed a boost converter to convert the 5V USB voltage to 170V. The nixie tubes were multiplexed by connecting their digits (cathodes) together; each digit had its own NPN transistor to effectively connect it to ground.
        Each tube's anode was connected using a PNP transistor (for high-side switching); only one tube is supposed to be on at a time. Each transistor's base is connected to a shift register's output; this way the entire display can be controlled over an SPI bus.
        To reduce ghosting on tubes that are supposed to be off, each cathode was connected together with a high-impedance resistor.
        Each functional block of the design is separated into a different PCB. This way I could reuse one of the components individually for future projects or easily replace a module if it breaks.
      </p>
      <p>
        The case uses laser-cut stainless steel panels, which are secured to an internal 3D-printed frame. The case was designed in OnShape. 
      </p>

      <div class="gallery">
        <img src="Pics/Urd/Front.jpeg">
        <img src="Pics/Urd/Back.jpeg">
        <img src="Pics/Urd/On.jpg">
      </div>
      <hr></hr>
    </div>

    <!-- Homebrew Computers Section -->
    <div>
      <h2 id="Homebrew Computers"><a href="https://github.com/Hardware7253/6502">Homebrew Computers</a> - 2022, 2024</h2>
      <p>Computers I built based off Ben Eater's <a href="https://www.youtube.com/@BenEater">YouTube videos</a></p>
      <div class="spacer"></div>

      <p>
        During 2022 I built an 8-bit computer on breadboards using various digital logic ICs. The design was very similar to the one in Ben Eater's 8-bit computer series, except I upgraded the RAM from 16 addresses to 256.
        To accommodate this change, the RAM was made to have a 12-bit word, so the upper 4 bits could be used for the instruction, and the lower 8 bits could be used as the operand (needed 8 bits so the new RAM would be addressable).
        The 4 instruction bits were connected on a separate bus straight to the instruction register and decoding logic; this way the main 8-bit bus didn't have to be expanded when the ALU and registers remained 8-bit.
        The video below shows the computer running a simple multiplication program for 9 x 13. The multiplication values are stored in two different memory addresses so they can easily be changed.
      </p>
      <p>
        Towards the end of 2024 I made a custom 6502 computer almost identical to the design that Ben Eater used in his videos. The 6502 chip runs at 1MHz and is connected to a ROM, RAM, and VIA chip for programmable IO.
        For quickly programming the ROM chip, I made my own EEPROM programmer with an Arduino Mega; I utilised port manipulation for this to greatly speed up the writing process. 
        I used an additional script to help me quickly assemble my program and format the resulting hex into an array of bytes to be used by the EEPROM programmer Arduino program.
        This project served as a proper introduction to assembly programming and low-level computer hardware.
      </p>

      <div class="gallery">
        <!-- <img src="Pics/Computers/8Bit.png"> -->
        <video controls muted>
          <source src="Pics/Computers/8Bit.mp4" type="video/mp4" />
        </video>
        <img src="Pics/Computers/6502.png">
      </div>
      <hr></hr>
    </div>

    <!-- Electronic Chess Board Section -->
    <div>
      <h2 id="Electronic Chessboard"><a href="https://github.com/Hardware7253/ElectronicChessBoard">Electronic Chessboard</a> - 2023</h2>
      <p>A chessboard with a built-in chess algorithm to play against</p>
      <div class="spacer"></div>

      <p>
        This board uses hall-effect sensors to detect the position of all the pieces on the board. Each piece isn't individually identifiable; the type of each piece is tracked as they move out from their starting position.
        The piece positions are read by the chess bot, which runs locally on the STM32F103Cx MCU. The bot controls one team, while the player controls the other.
        LEDs are used to indicate the chess bot's moves, while the player's moves are read by the hall-effect sensors.
      </p>
      <p>
        The chess bot was initially written in Rust to run on a PC; this was done to make debugging and testing easier. Then, once the bot was done, it could be ported to run on the embedded hardware.
        To do this, I simply removed the unit tests and features that required heap memory allocation, such as vectors and hashmaps. The rest of the code that runs on the MCU reads the physical board and handles the UI.
      </p>
      <p>
        Each position on the chessboard has its own hall-effect sensor and LED for reading piece positions and indicating moves. To make these 128 inputs/outputs more manageable, the LEDs were connected in a grid.
        Then the rows and columns had their own multiplexer IC such that the MUX input bits could be used as x and y coordinates. The hall-effect sensors used a similar approach, except each sensor was connected straight to a MUX;
        no grid was used. The multiplexers for the hall sensors allow any of the 64 sensors to be connected to a single pin which is read by the microcontroller.
        Finally, the MUX inputs were connected to shift registers to reduce the number of pins required to select an LED or hall sensor.
      </p>

      <div class="gallery">
        <img src="Pics/ElectronicChessBoard/Board.jpg">
        <video controls muted>
          <source src="Pics/ElectronicChessBoard/ComputerMove.mp4" type="video/mp4" />
        </video>
        <img src="Pics/ElectronicChessBoard/Test.png">
      </div>
      <hr></hr>
    </div>

    <!-- DAP Section -->
    <div>
      <h2 id="Digital Audio Player">Digital Audio Player - Current Project</h2>
      <p>A digital audio player that runs on embedded hardware</p>
      <div class="spacer"></div>

      <p>
        Near the start of 2025, my digital audio player's 3.5mm jack stopped working. So I purchased a newer model that came in at a lower price point, but I was unimpressed with this model's buggy software and worse battery life.
        Both DAPs I owned also featured terrible repairability because of their phone-like construction.
        The DAP market is small and is only served by a handful of companies, so I decided to try to make my own DAP that could address the shortcomings of the DAPs made by the major players.
        I decided that my DAP would use a microcontroller to keep costs down, and the software would run bare-metal to reduce performance overhead. Currently my goal is to play music by file hierarchy to keep things simple.
      </p>
      <p>
        The project is still in early stages. So far I've been experimenting with SD cards and the exFAT filesystem on an STM32F4 development board.
        I've been successful in reading the boot sector from the SD card and the contents of the filesystem root directory.
        Like my other projects, I'm writing the software in Rust; currently I'm not using any libraries for reading the exFAT filesystem.
        I've also made a prototype board for the <a href="https://github.com/Hardware7253/BreadBat">battery charger</a> with some circuit protection (overvoltage, undervoltage, short circuit).
        I realised I didn't consider the dropout voltage of the regulator while designing this board, so it doesn't output the correct voltage.
        For the battery circuitry in the actual DAP I'll likely have to use a buck converter to get around this limitation.
      </p>
      <p>
      </p>

      <div class="gallery">
        <img src="Pics/DAP/Charger.jpg">
        <img src="Pics/DAP/Prototype.jpg">
      </div>
      <hr></hr>
    </div>


  </main>

</body>

<br></br>
<br></br>
<br></br>
<footer>
  <p>Last Edit: 15/06/2025</p>
</footer>

</html>
